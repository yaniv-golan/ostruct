# Security Rules Reference

This document details the security rules used in vulnerability scanning, their categories, and remediation strategies.

## Injection Vulnerabilities

### SQL Injection

- **Rule ID**: `injection.sql`
- **Severity**: Critical
- **Description**: Detects potential SQL injection vulnerabilities
- **Patterns**:

  ```python
  # Vulnerable
  query = f"SELECT * FROM users WHERE id = {user_id}"

  # Secure
  query = "SELECT * FROM users WHERE id = ?"
  cursor.execute(query, (user_id,))
  ```

### Command Injection

- **Rule ID**: `injection.command`
- **Severity**: Critical
- **Description**: Identifies command injection risks
- **Patterns**:

  ```python
  # Vulnerable
  os.system(f"ping {host}")

  # Secure
  subprocess.run(["ping", host], capture_output=True)
  ```

## Cross-Site Scripting (XSS)

### Reflected XSS

- **Rule ID**: `xss.reflected`
- **Severity**: High
- **Description**: Detects reflected XSS vulnerabilities
- **Patterns**:

  ```python
  # Vulnerable
  return f"<p>Hello, {user_input}</p>"

  # Secure
  return f"<p>Hello, {escape(user_input)}</p>"
  ```

### Stored XSS

- **Rule ID**: `xss.stored`
- **Severity**: High
- **Description**: Identifies stored XSS risks
- **Patterns**:

  ```python
  # Vulnerable
  db.execute("INSERT INTO comments (content) VALUES (?)", [user_content])

  # Secure
  db.execute("INSERT INTO comments (content) VALUES (?)", [sanitize_html(user_content)])
  ```

## Authentication Issues

### Weak Password Storage

- **Rule ID**: `auth.password_storage`
- **Severity**: Critical
- **Description**: Detects insecure password storage
- **Patterns**:

  ```python
  # Vulnerable
  password_hash = hashlib.md5(password.encode()).hexdigest()

  # Secure
  password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())
  ```

### Insecure Session Management

- **Rule ID**: `auth.session`
- **Severity**: High
- **Description**: Identifies session security issues
- **Patterns**:

  ```python
  # Vulnerable
  session['user_id'] = user_id

  # Secure
  session['user_id'] = user_id
  session.permanent = True
  app.permanent_session_lifetime = timedelta(minutes=30)
  ```

## Authorization Flaws

### Missing Access Control

- **Rule ID**: `auth.access_control`
- **Severity**: High
- **Description**: Detects missing access controls
- **Patterns**:

  ```python
  # Vulnerable
  @app.route("/admin")
  def admin_panel():
      return render_template("admin.html")

  # Secure
  @app.route("/admin")
  @requires_role('admin')
  def admin_panel():
      return render_template("admin.html")
  ```

### Insecure Direct Object Reference

- **Rule ID**: `auth.idor`
- **Severity**: High
- **Description**: Identifies IDOR vulnerabilities
- **Patterns**:

  ```python
  # Vulnerable
  return db.get_user_data(user_id)

  # Secure
  if current_user.id == user_id:
      return db.get_user_data(user_id)
  ```

## Sensitive Data Exposure

### Logging Sensitive Data

- **Rule ID**: `data.logging`
- **Severity**: Medium
- **Description**: Detects sensitive data in logs
- **Patterns**:

  ```python
  # Vulnerable
  logging.info(f"User login: {username}, password: {password}")

  # Secure
  logging.info(f"User login attempt: {username}")
  ```

### Insecure Data Storage

- **Rule ID**: `data.storage`
- **Severity**: High
- **Description**: Identifies insecure data storage
- **Patterns**:

  ```python
  # Vulnerable
  config = {'api_key': 'secret123'}

  # Secure
  config = {'api_key': os.getenv('API_KEY')}
  ```

## Security Misconfiguration

### Debug Information Exposure

- **Rule ID**: `config.debug`
- **Severity**: Medium
- **Description**: Detects exposed debug information
- **Patterns**:

  ```python
  # Vulnerable
  app.run(debug=True)

  # Secure
  app.run(debug=False)
  ```

### Insecure Headers

- **Rule ID**: `config.headers`
- **Severity**: Medium
- **Description**: Identifies missing security headers
- **Patterns**:

  ```python
  # Vulnerable
  # No security headers

  # Secure
  @app.after_request
  def add_security_headers(response):
      response.headers['X-Content-Type-Options'] = 'nosniff'
      response.headers['X-Frame-Options'] = 'DENY'
      return response
  ```

## Best Practices

1. **Input Validation**
   - Validate all user input
   - Use whitelisting over blacklisting
   - Apply context-specific validation

2. **Output Encoding**
   - Encode data for its intended context
   - Use framework-provided encoders
   - Apply multiple encoding layers when needed

3. **Access Control**
   - Implement role-based access control
   - Use principle of least privilege
   - Validate access at each request

4. **Error Handling**
   - Use custom error pages
   - Avoid exposing stack traces
   - Log errors securely

5. **Security Headers**
   - Implement all recommended headers
   - Configure CSP appropriately
   - Regular header audits
