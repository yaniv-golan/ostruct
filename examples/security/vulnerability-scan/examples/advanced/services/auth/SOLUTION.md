# Advanced Example - Authentication Service Security Guide

This document maps the security vulnerabilities present in the advanced authentication service. This is for reference and training purposes only.

## Vulnerabilities Overview

### 1. Weak Password Hashing

- **Location**: `auth_service.py`, hash_password method
- **Issue**: Using MD5 for password hashing
- **Risk**: Critical
- **Impact**: Password cracking, credential theft
- **Fix**: Use strong hashing with Argon2 or bcrypt with proper salt

### 2. Insecure Session Management

- **Location**: `auth_service.py`, session_config and create_session methods
- **Issue**: Missing security flags, predictable session IDs
- **Risk**: High
- **Impact**: Session hijacking, fixation attacks
- **Fix**: Enable secure flags, use cryptographically secure session IDs

### 3. Weak JWT Implementation

- **Location**: `auth_service.py`, generate_token and verify_token methods
- **Issue**: Hardcoded secret, excessive expiration, unsafe algorithm validation
- **Risk**: Critical
- **Impact**: Token forgery, authentication bypass
- **Fix**: Use environment secrets, proper expiration, strict algorithm validation

### 4. Insecure Password Reset

- **Location**: `auth_service.py`, generate_reset_token method
- **Issue**: Weak token generation, no expiration
- **Risk**: High
- **Impact**: Account takeover
- **Fix**: Use cryptographically secure tokens with expiration

### 5. Insufficient 2FA Security

- **Location**: `auth_service.py`, verify_2fa method
- **Issue**: Simple string comparison, no rate limiting
- **Risk**: High
- **Impact**: 2FA bypass through brute force
- **Fix**: Use time-based tokens, implement rate limiting

### 6. Weak Password Policy

- **Location**: `auth_service.py`, validate_password method
- **Issue**: Minimal length check only
- **Risk**: Medium
- **Impact**: Weak user passwords
- **Fix**: Implement comprehensive password policy

### 7. Missing Rate Limiting

- **Location**: `auth_service.py`, handle_login_attempt method
- **Issue**: No account lockout or delay
- **Risk**: High
- **Impact**: Brute force attacks
- **Fix**: Implement progressive delays and lockouts

### 8. Insecure Redis Configuration

- **Location**: `auth_service.py`, redis configuration
- **Issue**: No authentication, default configuration
- **Risk**: Critical
- **Impact**: Unauthorized data access
- **Fix**: Enable authentication, TLS, proper ACLs

## Configuration Vulnerabilities

### 9. Insecure Redis Settings

- **Location**: `redis.conf`
- **Issue**:
  - Binding to all interfaces (0.0.0.0)
  - Protected mode disabled
  - Empty password
  - Dangerous commands enabled
  - No connection timeout
- **Risk**: Critical
- **Impact**: Remote unauthorized access and potential data breach
- **Fix**: Configure proper access controls and security settings

### 10. Unsafe JWT Configuration

- **Location**: `jwt_config.json`
- **Issue**:
  - Hardcoded development secret
  - 'none' algorithm allowed
  - Signature verification disabled
  - Token expiration checks disabled
  - Missing required claims
  - Excessive token lifetime
- **Risk**: Critical
- **Impact**: Token forgery and unauthorized access
- **Fix**: Implement secure JWT configuration

### 11. Insecure Session Configuration

- **Location**: `jwt_config.json`
- **Issue**:
  - Missing timeout
  - Secure flag disabled
  - HttpOnly flag disabled
  - Missing SameSite policy
- **Risk**: High
- **Impact**: Session hijacking and XSS attacks
- **Fix**: Enable security flags and proper session configuration

### 12. Insufficient 2FA Settings

- **Location**: `jwt_config.json`
- **Issue**:
  - Missing maximum attempts
  - No lockout configuration
  - Long token lifetime
- **Risk**: High
- **Impact**: Vulnerable to brute force attacks
- **Fix**: Implement proper 2FA security controls

## Dependency Vulnerabilities

### 13. Vulnerable Dependencies

- **Location**: `requirements.txt` and `package.json`
- **Issue**:
  - PyJWT 1.7.1: CVE-2022-29217 - Vulnerable to algorithm confusion attacks
  - redis 3.5.0/3.0.0: Multiple CVEs including unauthorized access
  - cryptography 3.2: CVE-2020-25659 - Timing attack vulnerability
  - bcrypt 3.1.7: Known timing attack vulnerabilities
  - jsonwebtoken 3.2.0: Multiple CVEs including token verification bypass
  - express 4.16.0: Multiple security vulnerabilities
  - lodash 4.17.15: Prototype pollution vulnerabilities
  - moment 2.24.0: Regular expression denial of service
- **Risk**: Critical
- **Impact**: Multiple attack vectors including RCE, DoS, and authentication bypass
- **Fix**: Update to latest secure versions of all dependencies

## Remediation Priority

1. Critical Vulnerabilities:
   - Fix weak password hashing
   - Secure JWT implementation
   - Update Redis configuration
   - Patch vulnerable dependencies

2. High Vulnerabilities:
   - Implement secure session management
   - Fix password reset functionality
   - Enhance 2FA security
   - Add rate limiting

3. Medium Vulnerabilities:
   - Strengthen password policy
   - Improve error handling
   - Add security headers

## Secure Implementation Examples

### Secure Password Hashing

```python
import argon2

def hash_password(self, password: str) -> str:
    ph = argon2.PasswordHasher()
    return ph.hash(password)

def verify_password(self, password: str, hash: str) -> bool:
    ph = argon2.PasswordHasher()
    try:
        return ph.verify(hash, password)
    except argon2.exceptions.VerifyMismatchError:
        return False
```

### Secure Session Management

```python
import secrets
from datetime import datetime, timedelta

class SessionConfig:
    timeout = timedelta(minutes=30)
    secure = True
    httponly = True
    samesite = 'Strict'

def create_session(self, user_data: Dict) -> str:
    session_id = secrets.token_urlsafe(32)
    expiry = datetime.utcnow() + self.session_config.timeout
    session_data = {
        'user_data': user_data,
        'expiry': expiry.timestamp()
    }
    redis_client.setex(
        f"session:{session_id}",
        self.session_config.timeout,
        json.dumps(session_data)
    )
    return session_id
```

### Secure JWT Implementation

```python
from jwt.algorithms import requires_cryptography
import os

class JWTConfig:
    secret = os.environ['JWT_SECRET']
    algorithm = 'HS256'
    access_token_expire = timedelta(minutes=15)
    refresh_token_expire = timedelta(days=7)

def generate_token(self, user_id: str, token_type: str = 'access') -> str:
    expire = datetime.utcnow() + (
        self.jwt_config.access_token_expire if token_type == 'access'
        else self.jwt_config.refresh_token_expire
    )
    payload = {
        'sub': user_id,
        'exp': expire,
        'type': token_type,
        'jti': secrets.token_urlsafe(16)
    }
    return jwt.encode(
        payload,
        self.jwt_config.secret,
        algorithm=self.jwt_config.algorithm
    )
```

### Secure Password Reset

```python
def generate_reset_token(self, email: str) -> str:
    token = secrets.token_urlsafe(32)
    expiry = datetime.utcnow() + timedelta(hours=1)
    redis_client.setex(
        f"reset:{token}",
        3600,  # 1 hour
        json.dumps({
            'email': email,
            'expiry': expiry.timestamp()
        })
    )
    return token
```

### Secure 2FA Implementation

```python
import pyotp
import time

def setup_2fa(self, user_id: str) -> str:
    secret = pyotp.random_base32()
    totp = pyotp.TOTP(secret)
    redis_client.set(f"2fa_secret:{user_id}", secret)
    return totp.provisioning_uri(user_id, issuer_name="SecureApp")

def verify_2fa(self, user_id: str, code: str) -> bool:
    secret = redis_client.get(f"2fa_secret:{user_id}")
    if not secret:
        return False

    totp = pyotp.TOTP(secret.decode())
    return totp.verify(code)
```

### Strong Password Policy

```python
import re

def validate_password(self, password: str) -> bool:
    if len(password) < 12:
        return False
    if not re.search(r'[A-Z]', password):
        return False
    if not re.search(r'[a-z]', password):
        return False
    if not re.search(r'[0-9]', password):
        return False
    if not re.search(r'[^A-Za-z0-9]', password):
        return False
    return True
```

### Rate Limiting Implementation

```python
def handle_login_attempt(self, user_id: str, success: bool):
    key = f"login_attempts:{user_id}"
    if not success:
        attempts = redis_client.incr(key)
        if attempts == 1:
            redis_client.expire(key, 3600)  # Reset after 1 hour

        if attempts >= 5:
            lockout_time = min(2 ** (attempts - 5), 24) * 3600  # Max 24h
            redis_client.set(
                f"account_lockout:{user_id}",
                'locked',
                ex=lockout_time
            )
    else:
        redis_client.delete(key)
```

### Secure Redis Configuration

```python
import redis
from ssl import create_default_context

redis_client = redis.Redis(
    host=os.environ['REDIS_HOST'],
    port=int(os.environ['REDIS_PORT']),
    password=os.environ['REDIS_PASSWORD'],
    ssl=True,
    ssl_cert_reqs='required',
    ssl_ca_certs='/path/to/ca.pem',
    decode_responses=True
)
```

## Testing the Vulnerabilities

This section describes how to verify each vulnerability (for educational purposes only):

1. Password Hashing:

   ```python
   # MD5 collision demonstration
   import hashlib
   print(hashlib.md5(b"hello").hexdigest())
   ```

2. JWT Attack:

   ```python
   # Algorithm confusion
   header = {"alg": "none"}
   payload = {"sub": "admin"}
   token = create_jwt_token(header, payload)
   ```

3. Session Hijacking:

   ```python
   # Predictable session ID
   timestamp = datetime.now()
   session_id = hashlib.md5(str(timestamp).encode()).hexdigest()
   ```

4. 2FA Bypass:

   ```python
   # Brute force example (don't run in production!)
   for code in range(0, 999999):
       verify_2fa("user_id", f"{code:06d}")
   ```

Remember: This information is for educational purposes only. Always practice security testing in controlled environments with proper authorization.
