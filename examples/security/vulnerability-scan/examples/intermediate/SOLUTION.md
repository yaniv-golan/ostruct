# Intermediate Example - Security Vulnerabilities Guide

This document maps the security vulnerabilities present in the intermediate API service. This is for reference and training purposes only.

## Vulnerabilities Overview

### 1. Insecure JWT Configuration

- **Location**: `api.py`, JWT configuration
- **Issue**: Hardcoded JWT secret and missing algorithm verification
- **Risk**: Critical
- **Impact**: Token forgery, authentication bypass
- **Fix**: Use secure secret from environment, specify algorithms

### 2. Command Injection

- **Location**: `api.py`, ping_host endpoint
- **Issue**: Unsanitized input in shell command
- **Risk**: Critical
- **Impact**: Remote code execution
- **Fix**: Use subprocess.run with args list

### 3. XML External Entity (XXE)

- **Location**: `api.py`, parse-xml endpoint
- **Issue**: Unsafe XML parsing
- **Risk**: High
- **Impact**: File disclosure, SSRF
- **Fix**: Disable external entity processing

### 4. Insecure Deserialization

- **Location**: `api.py`, load_config function
- **Issue**: Unsafe JSON deserialization
- **Risk**: High
- **Impact**: Code execution, data tampering
- **Fix**: Validate JSON schema, use safe deserializer

### 5. Information Disclosure

- **Location**: `api.py`, debug endpoint
- **Issue**: Exposing sensitive configuration
- **Risk**: High
- **Impact**: Credential leakage
- **Fix**: Remove debug endpoint or restrict access

### 6. CORS Misconfiguration

- **Location**: `api.py`, CORS middleware
- **Issue**: Overly permissive CORS policy
- **Risk**: Medium
- **Impact**: Cross-origin attacks
- **Fix**: Restrict to specific origins

## Secure Implementation Examples

### Secure JWT Configuration

```python
import os
from jwt.algorithms import requires_cryptography

JWT_SECRET = os.environ['JWT_SECRET']
JWT_ALGORITHMS = ['HS256']

@app.get("/protected")
async def protected_route(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=JWT_ALGORITHMS)
        return {"data": payload['sub']}
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401)
```

### Secure Command Execution

```python
@app.get("/ping/{host}")
async def ping_host(host: str):
    if not is_valid_hostname(host):
        raise HTTPException(status_code=400)
    result = subprocess.run(
        ["ping", "-c", "1", host],
        capture_output=True,
        text=True,
        check=True
    )
    return {"result": result.stdout}
```

### Secure XML Parsing

```python
import defusedxml.ElementTree as ET

@app.post("/parse-xml")
async def parse_xml(request: Request):
    body = await request.body()
    try:
        root = ET.fromstring(body)
        return {"root_tag": root.tag}
    except ET.ParseError:
        raise HTTPException(status_code=400)
```

### Secure Configuration Loading

```python
from pydantic import BaseSettings

class Settings(BaseSettings):
    database_url: str
    api_keys: list[str]
    admin_users: list[str]

    class Config:
        env_file = '.env'

settings = Settings()
```

### Secure CORS Configuration

```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=['https://trusted-origin.com'],
    allow_credentials=True,
    allow_methods=['GET', 'POST'],
    allow_headers=['Authorization'],
)
```

## Testing the Vulnerabilities

This section describes how to verify each vulnerability (for educational purposes only):

1. JWT Attack:

   ```
   # Create token with 'none' algorithm
   header = {"alg": "none", "typ": "JWT"}
   payload = {"sub": "admin"}
   token = create_jwt_token(header, payload, "")
   ```

2. Command Injection:

   ```
   GET /ping/localhost;cat%20/etc/passwd
   ```

3. XXE Attack:

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
   <root>&xxe;</root>
   ```

4. Debug Info Leak:

   ```
   GET /debug
   # Observe sensitive configuration data
   ```

Remember: This information is for educational purposes only. Always practice security testing in controlled environments with proper authorization.
