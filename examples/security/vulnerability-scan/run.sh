#!/bin/bash

# Security Vulnerability Scanner Runner Script
# This script uses the OpenAI Structured CLI to scan code for security vulnerabilities

set -e

# Default values
SCAN_DIR=""
SCAN_TYPE="full"
MIN_SEVERITY=""
RULES=""
CHECK_DEPS=false
EXCLUDE_PATTERNS=""
OUTPUT_FILE=""
VERBOSE=false

# Function to print usage
print_usage() {
    echo "Usage: $0 [OPTIONS] SCAN_DIR"
    echo
    echo "Scan code for security vulnerabilities using OpenAI Structured CLI"
    echo
    echo "Options:"
    echo "  -t, --type TYPE       Scan type: full, quick, custom (default: full)"
    echo "  -s, --severity LEVEL  Minimum severity: critical, high, medium, low"
    echo "  -r, --rules RULES     Specific rules to apply (comma-separated)"
    echo "  -d, --check-deps      Include dependency vulnerability scanning"
    echo "  -e, --exclude PATTERN Exclude patterns (comma-separated)"
    echo "  -o, --output FILE     Write results to file"
    echo "  -v, --verbose         Enable verbose logging"
    echo "  -h, --help           Show this help message"
    echo
    echo "Example:"
    echo "  $0 --type full --check-deps --severity high ./src"
}

# Check for OpenAI API key
check_api_key() {
    if [ -z "${OPENAI_API_KEY}" ]; then
        echo "Error: OPENAI_API_KEY environment variable is not set"
        echo "Please set your OpenAI API key:"
        echo "export OPENAI_API_KEY='your-api-key'"
        return 1
    fi
    return 0
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -t|--type)
            SCAN_TYPE="$2"
            shift 2
            ;;
        -s|--severity)
            MIN_SEVERITY="$2"
            shift 2
            ;;
        -r|--rules)
            RULES="$2"
            shift 2
            ;;
        -d|--check-deps)
            CHECK_DEPS=true
            shift
            ;;
        -e|--exclude)
            EXCLUDE_PATTERNS="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            print_usage
            exit 0
            ;;
        *)
            if [[ -z "$SCAN_DIR" ]]; then
                SCAN_DIR="$1"
            else
                echo "Error: Unexpected argument '$1'"
                print_usage
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate requirements
if ! check_api_key; then
    exit 1
fi

# Validate required arguments
if [[ -z "$SCAN_DIR" ]]; then
    echo "Error: SCAN_DIR is required"
    print_usage
    exit 1
fi

# Get absolute paths
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
if [[ -d "$SCAN_DIR" ]]; then
    SCAN_DIR="$(cd "$SCAN_DIR" && pwd)"
else
    echo "Error: Directory '$SCAN_DIR' does not exist"
    exit 1
fi

# Validate scan type
case $SCAN_TYPE in
    full|quick|custom)
        ;;
    *)
        echo "Error: Invalid scan type '$SCAN_TYPE'"
        echo "Supported types: full, quick, custom"
        exit 1
        ;;
esac

# Build the ostruct command
CMD="ostruct"
CMD+=" --task-file $SCRIPT_DIR/prompts/task.j2"
CMD+=" --schema-file $SCRIPT_DIR/schemas/scan_result.json"
CMD+=" --system-prompt-file $SCRIPT_DIR/prompts/system.txt"
if [[ "$VERBOSE" == true ]]; then
    CMD+=" --verbose"
fi

# Change to scan directory before running command
cd "$SCAN_DIR"

CMD+=" --dir code_files=."
CMD+=" --dir-recursive"
CMD+=" --dir-ext py,js,java,go,rb,php"
CMD+=" --var scan_type=$SCAN_TYPE"

# Find dependency files (if enabled)
if [[ "$CHECK_DEPS" == true ]]; then
    CMD+=" --var check_dependencies=true"
    # Match common dependency files recursively
    CMD+=" --files dependency_files=./**/{requirements.txt,package.json,pom.xml,build.gradle,Gemfile,composer.json}"
fi

# Find configuration files
CMD+=" --files config_files=./**/*.{yaml,yml,json,xml,ini,conf,config,properties}"

# Add optional parameters
if [[ -n "$MIN_SEVERITY" ]]; then
    CMD+=" --var min_severity=$MIN_SEVERITY"
fi

if [[ -n "$RULES" ]]; then
    # Convert comma-separated list to JSON array
    RULES_JSON="[$(echo "$RULES" | sed 's/,/","/g' | sed 's/.*/"&"/')"
    CMD+=" --var rules=$RULES_JSON"
fi

if [[ -n "$EXCLUDE_PATTERNS" ]]; then
    # Convert comma-separated list to JSON array
    PATTERNS_JSON="[$(echo "$EXCLUDE_PATTERNS" | sed 's/,/","/g' | sed 's/.*/"&"/')"
    CMD+=" --var exclude_patterns=$PATTERNS_JSON"
fi

# Run the scan
echo "Running security vulnerability scan..."
echo "Target directory: $SCAN_DIR"
echo "Scan type: $SCAN_TYPE"
if [[ -n "$MIN_SEVERITY" ]]; then
    echo "Minimum severity: $MIN_SEVERITY"
fi
if [[ -n "$RULES" ]]; then
    echo "Rules: $RULES"
fi
if [[ "$CHECK_DEPS" == true ]]; then
    echo "Checking dependencies: yes"
fi
echo "Command: $CMD"

if [[ -n "$OUTPUT_FILE" ]]; then
    echo "Output will be written to: $OUTPUT_FILE"
    $CMD > "$OUTPUT_FILE"
else
    $CMD
fi

# Return to original directory
cd - > /dev/null

# Check exit code
EXIT_CODE=$?
if [[ $EXIT_CODE -eq 0 ]]; then
    if [[ -n "$OUTPUT_FILE" ]] && command -v jq >/dev/null 2>&1; then
        echo -e "\nScan Summary:"
        echo "============="
        jq '.scan_summary' "$OUTPUT_FILE"

        echo -e "\nCritical and High Risk Vulnerabilities:"
        echo "====================================="
        jq '.vulnerabilities[] | select(.risk_level == "critical" or .risk_level == "high") | {risk_level, type, file_path, description}' "$OUTPUT_FILE"
    fi
    echo "Scan completed successfully"
else
    echo "Scan failed with exit code $EXIT_CODE"
    exit $EXIT_CODE
fi
