# Security Vulnerability Scanning - Three Approaches

This example demonstrates three distinct approaches to automated security vulnerability scanning, each optimized for different use cases and budgets. Based on comprehensive testing and expert optimization, we provide clear guidance on when to use each approach.

## ğŸ¯ **Choose Your Approach**

Based on live testing and optimization, we offer three approaches with validated performance metrics:

| Approach | Tokens (Single File) | Cost (Single/Directory) | Quality | Best For |
|----------|--------|------|---------|----------|
| **Static Analysis** | 6,762 | $0.18 / $0.26 | Good | Budget-conscious projects |
| **Code Interpreter** | 6,406 | $0.18 / ~$0.27 | Superior | Professional security analysis â­ |
| **Hybrid Analysis** | 15,970 | $0.20 / ~$0.35 | Comprehensive | Critical applications |

## ğŸ“Š **Approach Comparison**

### 1. Static Analysis (`static_analysis.j2`)

- **Tokens**: 6,762 (single file) / 39,354 (directory)
- **Cost**: $0.1807 (single) / $0.2622 (directory)
- **Quality**: Finds all major vulnerabilities with good remediation
- **Use Case**: Budget-conscious projects, quick security reviews
- **File Routing**: `-f code` (direct template access) or `-d code dir -R`

### 2. Code Interpreter (`code_interpreter.j2`) â­ **RECOMMENDED**

- **Tokens**: 6,406 (single file) / ~40,000 (directory)
- **Cost**: $0.1799 (single) / ~$0.27 (directory)
- **Quality**: Superior severity assessment, evidence-based analysis
- **Use Case**: Professional security analysis, audit-grade reports
- **File Routing**: `--fca code` (uploaded for execution) or `-dc dir`

### 3. Hybrid Analysis (`hybrid_analysis.j2`)

- **Tokens**: 15,970 (single file) / ~55,000 (directory)
- **Cost**: $0.2038 (single) / ~$0.35 (directory)
- **Quality**: Maximum depth with cross-validation
- **Use Case**: Critical applications, comprehensive security audits
- **File Routing**: `-f code` + `--fca code_exec` (both approaches)

## ğŸš€ **Usage Examples**

### Static Analysis (Budget Option)

```bash
# Single file analysis
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  -f code examples/basic/app.py \
  --sys-file prompts/system.txt

# ğŸ¯ RECOMMENDED: Entire project analysis (all files)
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  -d code examples -R \
  --sys-file prompts/system.txt \
  --timeout 180

# For multiple files, run separate analyses:
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  -f code examples/intermediate/api_service.py \
  --sys-file prompts/system.txt \
  --timeout 120

# Advanced microservice analysis
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  -f code examples/advanced/services/auth/auth_service.py \
  --sys-file prompts/system.txt
```

### Code Interpreter (Recommended)

```bash
# Professional security analysis
ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  --fca code examples/basic/app.py \
  --sys-file prompts/system.txt

# ğŸ¯ RECOMMENDED: Entire project analysis (all files)
ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  -dc examples \
  --sys-file prompts/system.txt \
  --timeout 240

# For multiple files, run separate analyses:
ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  --fca code examples/intermediate/api_service.py \
  --sys-file prompts/system.txt \
  --timeout 120

# Microservice security audit
ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  --fca code examples/advanced/services/auth/auth_service.py \
  --sys-file prompts/system.txt \
  --timeout 180
```

### Hybrid Analysis (Premium)

```bash
# Comprehensive security audit
ostruct run prompts/hybrid_analysis.j2 schemas/scan_result.json \
  -f code examples/basic/app.py \
  --fca code_exec examples/basic/app.py \
  --sys-file prompts/system.txt

# ğŸ¯ RECOMMENDED: Entire project analysis (all files)
ostruct run prompts/hybrid_analysis.j2 schemas/scan_result.json \
  -d code examples -R \
  -dc examples \
  --sys-file prompts/system.txt \
  --timeout 300

# For multiple files, run separate analyses:
ostruct run prompts/hybrid_analysis.j2 schemas/scan_result.json \
  -f code examples/intermediate/api_service.py \
  --fca code_exec examples/intermediate/api_service.py \
  --sys-file prompts/system.txt \
  --timeout 180

# Advanced microservice analysis
ostruct run prompts/hybrid_analysis.j2 schemas/scan_result.json \
  -f code examples/advanced/services/auth/auth_service.py \
  --fca code_exec examples/advanced/services/auth/auth_service.py \
  --sys-file prompts/system.txt \
  --timeout 240
```

## âš ï¸ **Important Considerations**

### **Timeout Guidelines**

Different approaches have different processing times:

- **Static Analysis**: Usually completes in 30-60 seconds
- **Code Interpreter**: May take 60-180 seconds (includes environment setup)
- **Hybrid Analysis**: Can take 120-300 seconds (most comprehensive)

**Recommended timeout values:**

```bash
# For simple files (< 1000 lines)
--timeout 120

# For complex files (1000-5000 lines)  
--timeout 180

# For large files or microservices (> 5000 lines)
--timeout 240
```

### **Multiple File Analysis**

**ğŸ¯ RECOMMENDED: Directory-Based Analysis**

For comprehensive project analysis, use directory options to analyze all files at once:

```bash
# Static Analysis - Entire project
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  -d code examples -R --sys-file prompts/system.txt

# Code Interpreter - Entire project  
ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  -dc examples --sys-file prompts/system.txt

# Hybrid Analysis - Entire project
ostruct run prompts/hybrid_analysis.j2 schemas/scan_result.json \
  -d code examples -R -dc examples --sys-file prompts/system.txt
```

**Alternative: Individual File Analysis**

**Current Limitation**: Templates expect a single `code` variable, so multiple files must be analyzed separately:

```bash
# âŒ This won't work (duplicate variable names):
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  -f code file1.py -f code file2.py

# âœ… Instead, run separate analyses:
ostruct run prompts/static_analysis.j2 schemas/scan_result.json -f code file1.py
ostruct run prompts/static_analysis.j2 schemas/scan_result.json -f code file2.py
```

### **Template Variable Requirements**

All current templates expect these specific variables:

- **Static Analysis**: `code` (file array)
- **Code Interpreter**: `code` (file array)
- **Hybrid Analysis**: `code` (template access) + `code_exec` (execution environment)

## ğŸ“ˆ **Expected Results**

All approaches will find the same core security vulnerabilities but with different levels of detail:

### Static Analysis Results

- âœ… **Comprehensive** vulnerability detection
- âœ… **Practical** remediation guidance
- âœ… **Fast** processing with direct file access
- âœ… **Cost-effective** baseline security assessment
- âœ… **Good** severity assessment (High/Medium/Low)

### Code Interpreter Results

- âœ… **Evidence-based** analysis with specific code references
- âœ… **AST parsing** and structural analysis
- âœ… **Advanced pattern detection** using Python tools
- âœ… **Professional audit-grade** output
- âœ… **Superior** severity assessment (Critical/High/Medium/Low)

### Hybrid Analysis Results

- âœ… **Cross-validation** between static and dynamic analysis
- âœ… **Comprehensive** security and quality metrics
- âœ… **Advanced execution** capabilities
- âœ… **Real-time syntax** validation
- âœ… **Maximum coverage** with multi-phase analysis

## ğŸ¯ **Recommendations**

### **For Most Projects: Code Interpreter** â­

- **Same cost** as static analysis for single files ($0.18)
- **Significantly better** analysis quality with evidence-based findings
- **Professional audit-grade** output with AST parsing
- **Superior severity assessment** prevents false positives

### **For Budget-Conscious Projects: Static Analysis**

- **Lowest cost** for directory analysis ($0.26 vs $0.27)
- **Still finds all major** security vulnerabilities
- **Fast processing** with minimal resource usage
- **Good remediation advice** with specific line numbers

### **For Critical Applications: Hybrid Analysis**

- **Maximum analysis depth** for critical systems
- **Cross-validation capabilities** between static and dynamic
- **Advanced execution** and complexity analysis
- **Only 13% more expensive** for comprehensive coverage ($0.20 vs $0.18)

## ğŸ“ **Directory Structure**

```
.
â”œâ”€â”€ README.md                    # This file
â”œâ”€â”€ prompts/                     # AI prompts (three approaches)
â”‚   â”œâ”€â”€ static_analysis.j2       # Budget-friendly static analysis
â”‚   â”œâ”€â”€ code_interpreter.j2      # Professional security analysis (recommended)
â”‚   â”œâ”€â”€ hybrid_analysis.j2       # Comprehensive audit approach
â”‚   â””â”€â”€ system.txt              # AI security expertise definition
â”œâ”€â”€ schemas/                     # Output structure
â”‚   â””â”€â”€ scan_result.json        # Vulnerability report schema
â”œâ”€â”€ examples/                    # Sample vulnerable code
â”‚   â”œâ”€â”€ basic/                  # Simple web application
â”‚   â”‚   â”œâ”€â”€ app.py              # Flask app with SQL injection, XSS
â”‚   â”‚   â”œâ”€â”€ requirements.txt    # Dependencies
â”‚   â”‚   â””â”€â”€ SOLUTION.md         # Security fixes guide
â”‚   â”œâ”€â”€ intermediate/           # API service
â”‚   â”‚   â””â”€â”€ api_service.py      # REST API with auth vulnerabilities
â”‚   â””â”€â”€ advanced/              # Microservices architecture
â”‚       â””â”€â”€ services/          # Service implementations
â”‚           â””â”€â”€ auth/          # Authentication service
â”‚               â”œâ”€â”€ auth_service.py    # JWT, Redis vulnerabilities
â”‚               â”œâ”€â”€ jwt_config.json    # Insecure JWT config
â”‚               â”œâ”€â”€ redis.conf         # Redis configuration
â”‚               â”œâ”€â”€ requirements.txt   # Service dependencies
â”‚               â””â”€â”€ SOLUTION.md        # Microservice security guide
â””â”€â”€ docs/                       # Documentation
    â”œâ”€â”€ customization.md        # How to customize scans
    â””â”€â”€ rules.md               # Security rules reference
```

## ğŸ” **Vulnerability Detection Capabilities**

All approaches detect:

### **Injection Vulnerabilities**

- SQL injection (string concatenation, format strings)
- OS command injection via subprocess, os.system
- Code injection through eval(), exec(), compile()
- LDAP injection, XML injection

### **Cross-Site Scripting (XSS)**

- Unescaped output in web contexts
- Direct rendering of user input
- Unsafe template rendering

### **Authentication & Authorization**

- Missing authentication checks
- Weak password policies
- Session management issues
- Privilege escalation vulnerabilities

### **Cryptographic Issues**

- Hardcoded passwords, API keys, secrets
- Weak cryptographic algorithms
- Plain text password storage
- Missing password hashing

### **Input Validation Issues**

- Missing input sanitization
- Insufficient data validation
- Path traversal vulnerabilities
- Buffer overflow potential

## ğŸ”§ **Integration Examples**

### GitHub Actions

```yaml
name: Security Scan
on: [push, pull_request]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Security Analysis
        run: |
          # Professional security analysis (recommended)
          ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
            --fca code src/app.py \
            --sys-file prompts/system.txt \
            --output-file security_report.json
```

### GitLab CI

```yaml
security_scan:
  stage: test
  script:
    # Budget-friendly option for CI/CD
    - ostruct run prompts/static_analysis.j2 schemas/scan_result.json
        -f code src/app.py
        --sys-file prompts/system.txt
  artifacts:
    reports:
      junit: security_report.json
```

### Docker

```bash
# Containerized security scanning
docker run --rm -v $(pwd):/workspace ostruct/security-scanner \
  ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  --fca code /workspace/src/app.py \
  --sys-file prompts/system.txt
```

## ğŸ“Š **Performance Benchmarks**

Based on live testing with actual ostruct dry-runs:

### **Single File Analysis** (`examples/basic/app.py` - 1,656 bytes)

| Metric | Static | Code Interpreter | Hybrid |
|--------|--------|------------------|--------|
| **Input Tokens** | 6,762 | 6,406 | 15,970 |
| **Estimated Cost** | $0.1807 | $0.1799 | $0.2038 |
| **Context Utilization** | 18.1% | 17.8% | 25.3% |
| **Analysis Quality** | Good | Superior | Comprehensive |
| **Processing Time** | Fastest | Fast | Moderate |

### **Directory Analysis** (All example files - 4 Python files, ~5KB total)

| Metric | Static | Code Interpreter | Hybrid |
|--------|--------|------------------|--------|
| **Input Tokens** | 39,354 | ~40,000* | ~55,000* |
| **Estimated Cost** | $0.2622 | ~$0.27* | ~$0.35* |
| **Context Utilization** | 43.5% | ~45%* | ~60%* |
| **Analysis Quality** | Comprehensive | Superior | Maximum |
| **Processing Time** | Fast | Moderate | Slower |

*Estimated based on static analysis baseline + tool overhead

## ğŸ“ **Educational Value**

This example demonstrates:

1. **Cost vs Quality Trade-offs**: Clear metrics for decision making
2. **File Routing Approaches**: When to use `-f` vs `--fca` vs both
3. **AI-Powered Security Analysis**: Beyond traditional static analysis tools
4. **Template Optimization**: Expert-optimized prompts for better results
5. **Production-Ready Templates**: Real-world security analysis capabilities

## ğŸ”— **Key Benefits Over Traditional Scanners**

1. **Contextual Understanding**
   - Understands code semantics and flow
   - Reduces false positives through context
   - Identifies complex vulnerability patterns

2. **Intelligent Analysis**
   - Prioritizes vulnerabilities by risk
   - Provides detailed exploit scenarios
   - Suggests specific remediation steps

3. **Flexible Approaches**
   - Choose based on budget and requirements
   - Scale from basic to comprehensive analysis
   - Validated performance metrics for planning

4. **Developer-Friendly Output**
   - Clear, actionable explanations
   - Code-specific fix suggestions
   - Professional audit-grade reports

## ğŸš€ **Getting Started**

1. **Choose your approach** based on budget and requirements
2. **Run the analysis** using the appropriate template
3. **Review the results** in the JSON output
4. **Implement fixes** based on remediation guidance
5. **Integrate** into your CI/CD pipeline

Start with the **Code Interpreter approach** for the best balance of cost and quality!
