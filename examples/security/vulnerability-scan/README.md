# Security Vulnerability Scanning

This use case demonstrates how to perform automated security vulnerability scanning across codebases using ostruct CLI with both traditional and enhanced multi-tool capabilities. It combines static analysis with AI-powered reasoning to identify potential security issues, suggest fixes, and provide detailed explanations.

## Problem This Solves

Security vulnerabilities in code can lead to serious breaches and data loss. Manual security reviews are time-consuming and often miss subtle issues. This automated scanning system provides comprehensive security analysis that can catch common vulnerabilities like SQL injection, XSS, and authentication bypass before they reach production, helping maintain secure coding practices across teams.

## Features

### Core Security Analysis

- Code pattern-based vulnerability detection
- Dependency vulnerability scanning
- Security best practice validation
- Intelligent vulnerability prioritization
- Detailed remediation suggestions
- Support for multiple programming languages

### Enhanced Multi-Tool Integration

- **Code Interpreter**: Execute code snippets to verify vulnerability conditions
- **File Search**: Search security documentation and best practices
- **MCP Servers**: Connect to external security databases and tools
- **Explicit File Routing**: Optimize scanning through targeted file analysis

## Directory Structure

```
.
├── README.md           # This file
├── prompts/           # AI prompts
│   ├── system.txt     # AI's security expertise definition
│   └── task.j2        # Scan request template
├── schemas/           # Output structure
│   └── scan_result.json
├── examples/          # Sample code to scan
│   ├── basic/        # Simple web application
│   │   ├── app.py        # Flask application
│   │   └── requirements.txt
│   ├── intermediate/ # API service
│   │   ├── src/         # Source code
│   │   └── deps/        # Dependencies
│   └── advanced/     # Microservices
│       ├── services/    # Service implementations
│       └── shared/      # Shared libraries
└── docs/             # Documentation
    ├── customization.md # How to customize scans
    └── rules.md        # Security rules reference
```

## Usage

### Traditional Usage (Unchanged)

These commands work exactly as before:

1. **Basic Directory Scan**:

   ```bash
   # Traditional pattern (still works)
   ostruct run prompts/task.j2 schemas/scan_result.json \
     -d code examples/basic \
     -R \
     --sys-file prompts/system.txt
   ```

2. **With Specific Security Rules**:

   ```bash
   # Traditional with rules (still works)
   ostruct run prompts/task.j2 schemas/scan_result.json \
     -d code examples/intermediate/src \
     -R \
     --sys-file prompts/system.txt \
     -J rules='["web","api"]'
   ```

3. **Dependency Vulnerability Scan**:

   ```bash
   # Traditional dependency scan (still works)
   ostruct run prompts/task.j2 schemas/scan_result.json \
     -d code examples/advanced \
     -R \
     --sys-file prompts/system.txt \
     -V check_dependencies=true
   ```

### Enhanced Multi-Tool Usage

#### Code Interpreter for Dynamic Analysis

Upload code for execution-based vulnerability verification:

```bash
# Code execution security analysis
ostruct run prompts/task.j2 schemas/scan_result.json \
  -fc examples/basic/app.py \
  -fc examples/basic/requirements.txt \
  --sys-file prompts/system.txt \
  -V scan_type=dynamic \
  -V check_dependencies=true

# Multi-service security scan
ostruct run prompts/task.j2 schemas/scan_result.json \
  -fc examples/advanced/services/ \
  --sys-file prompts/system.txt \
  --json-var rules='["web","api","microservices"]' \
  --output-file security_report.json
```

#### File Search for Security Documentation

Search security documentation and best practices:

```bash
# Security scan with documentation context
ostruct run prompts/task.j2 schemas/scan_result.json \
  -fc examples/intermediate/src/ \
  -fs docs/ \
  --sys-file prompts/system.txt \
  --json-var rules='["web","api"]'

# Comprehensive security analysis
ostruct run prompts/task.j2 schemas/scan_result.json \
  -fc source_code/ \
  -fs security_docs/ \
  -ft security_configs/ \
  --sys-file prompts/system.txt \
  --output-file comprehensive_scan.json
```

#### MCP Server Integration for External Security Data

Connect to security databases and vulnerability feeds:

```bash
# Security scan with external vulnerability database
ostruct run prompts/task.j2 schemas/scan_result.json \
  -fc examples/basic/ \
  --mcp-server deepwiki@https://mcp.deepwiki.com/sse \
  --sys-file prompts/system.txt \
  -V repo_owner=your-org \
  -V repo_name=your-repo \
  -V check_dependencies=true

# Multi-tool security analysis with repository context
ostruct run prompts/task.j2 schemas/scan_result.json \
  -fc source_code/ \
  -fs documentation/ \
  --mcp-server deepwiki@https://mcp.deepwiki.com/sse \
  --sys-file prompts/system.txt \
  --output-file enhanced_security_report.json
```

#### Configuration-Driven Security Scanning

Use persistent configuration for consistent security analysis:

```bash
# Create security-focused ostruct.yaml
cat > security_config.yaml << EOF
models:
  default: gpt-4o
tools:
  code_interpreter:
    auto_download: true
    output_directory: "./security_analysis"
  file_search:
    max_results: 25
mcp:
  deepwiki: "https://mcp.deepwiki.com/sse"
operation:
  timeout_minutes: 30
limits:
  max_cost_per_run: 5.00
EOF

# Run comprehensive security scan
ostruct --config security_config.yaml run prompts/task.j2 schemas/scan_result.json \
  -fc src/ \
  -fs security_docs/ \
  --sys-file prompts/system.txt
```

## Example Files

1. **Basic Application**
   - Simple web application with common vulnerabilities
   - Dependency management files
   - Configuration files

2. **Intermediate Setup**
   - REST API implementation
   - Authentication flows
   - Database interactions

3. **Advanced Example**
   - Microservices architecture
   - Inter-service communication
   - Shared security components

## Integration

### GitHub Actions

```yaml
- name: Security Scan
  run: |
    ostruct run prompts/task.j2 schemas/scan_result.json \
      -d code ./src \
      -R \
      --sys-file prompts/system.txt
```

### GitLab CI

```yaml
security_scan:
  script:
    - ostruct run prompts/task.j2 schemas/scan_result.json \
        -d code ./src \
        -R \
        --sys-file prompts/system.txt
```

## Key Benefits Over Traditional Scanners

1. **Contextual Understanding**
   - Understands code semantics and flow
   - Reduces false positives through context
   - Identifies complex vulnerability patterns

2. **Intelligent Analysis**
   - Prioritizes vulnerabilities by risk
   - Provides detailed exploit scenarios
   - Suggests specific remediation steps

3. **Comprehensive Coverage**
   - Scans application code
   - Checks dependencies
   - Validates configurations
   - Reviews security practices

4. **Developer-Friendly Output**
   - Clear, actionable explanations
   - Code-specific fix suggestions
   - Best practice recommendations

## Prerequisites

- OpenAI Structured CLI installed
- OpenAI API key configured
- Source code to scan

## Limitations

- Dynamic runtime vulnerabilities require additional tools
- Some language-specific features may need custom rules
- Large codebases are processed in chunks
