# Security Vulnerability Scanning - Three Approaches

This example demonstrates three distinct approaches to automated security vulnerability scanning, each optimized for different use cases and budgets. Based on comprehensive testing and expert optimization, we provide clear guidance on when to use each approach.

## üîí Security & Data Privacy Notice

Please be aware of the following when using `ostruct` with different file routing options:

* **File Uploads to OpenAI Tools**:
  * Flags like `--file ci:`, `--dir ci:` (for Code Interpreter) and `--file fs:`, `--dir fs:` (for File Search) **will upload your files** to OpenAI's services for processing.
  * Ensure you understand OpenAI's data usage policies before using these options with sensitive data.

* **Template-Only Access & Prompt Content**:
  * Flags like `-ft`, `--fta`, `-dt`, `--dta` (and legacy `-f`, `-d`) are designed for template-only access and **do not directly upload files to Code Interpreter or File Search services.**
  * **However, if your Jinja2 template includes the content of these files (e.g., using `{{ my_file.content }}`), that file content WILL become part of the prompt sent to the main OpenAI Chat Completions API.**
  * For large files or sensitive data that should not be part of the main prompt, even if used with `-ft`, avoid rendering their full content in the template or use redaction techniques.
  * If a large file is intended for analysis or search, prefer using `-fc`/`-fs` to optimize token usage and costs, and to prevent exceeding model context limits by inadvertently including its full content in the prompt. `ostruct` will issue a warning if you attempt to render the content of a large template-only file.

Always review which files are being routed to which tools and how their content is used in your templates to manage data privacy and API costs effectively.

For detailed information about data handling and security best practices, see the [Security Overview](../../../docs/source/security/overview.rst) documentation.

## üéØ **Choose Your Approach**

Based on live testing and optimization, we offer three approaches with validated performance metrics:

| Approach | Tokens (Single File) | Cost (Single/Directory) | Quality | Best For |
|----------|--------|------|---------|----------|
| **Static Analysis** | 6,762 | $0.18 / $0.26 | Good | Budget-conscious projects |
| **Code Interpreter** | 6,406 | $0.18 / ~$0.27 | Superior | Professional security analysis ‚≠ê |
| **Hybrid Analysis** | 15,970 | $0.20 / ~$0.35 | Comprehensive | Critical applications |

## üìä **Approach Comparison**

### 1. Static Analysis (`static_analysis.j2`)

* **Tokens**: 6,762 (single file) / 39,354 (directory)
* **Cost**: $0.1807 (single) / $0.2622 (directory)
* **Quality**: Finds all major vulnerabilities with good remediation
* **Use Case**: Budget-conscious projects, quick security reviews
* **File Routing**: `-f code` (direct template access) or `--dir code dir`

### 2. Code Interpreter (`code_interpreter.j2`) ‚≠ê **RECOMMENDED**

* **Tokens**: 6,406 (single file) / ~40,000 (directory)
* **Cost**: $0.1799 (single) / ~$0.27 (directory)
* **Quality**: Superior severity assessment, evidence-based analysis
* **Use Case**: Professional security analysis, audit-grade reports
* **File Routing**: `--file ci:code` (uploaded for execution) or `--dir ci:code dir`

### 3. Hybrid Analysis (`hybrid_analysis.j2`)

* **Tokens**: 15,970 (single file) / ~55,000 (directory)
* **Cost**: $0.2038 (single) / ~$0.35 (directory)
* **Quality**: Maximum depth with cross-validation
* **Use Case**: Critical applications, comprehensive security audits
* **File Routing**: `--dir code` + `--dir ci:code_exec` (both approaches)

## üöÄ **Usage Examples**

### Static Analysis (Budget Option)

```bash
# Single file analysis
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  --file code examples/basic/app.py

# üéØ RECOMMENDED: Entire project analysis (all files)
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  --dir code examples \
  --timeout 180

# For multiple files, run separate analyses:
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  --file code examples/intermediate/api_service.py \
  --timeout 120

# Advanced microservice analysis
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  -f code examples/advanced/services/auth/auth_service.py \
  --sys-file prompts/system.txt
```

### Code Interpreter (Recommended)

```bash
# Professional security analysis
ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  --file ci:code examples/basic/app.py \
  --sys-file prompts/system.txt

# üéØ RECOMMENDED: Entire project analysis (all files)
ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  --dir ci:code examples \
  --sys-file prompts/system.txt \
  --timeout 240

# For multiple files, run separate analyses:
ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  --file ci:code examples/intermediate/api_service.py \
  --sys-file prompts/system.txt \
  --timeout 120

# Microservice security audit
ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  --file ci:code examples/advanced/services/auth/auth_service.py \
  --sys-file prompts/system.txt \
  --timeout 180
```

### Hybrid Analysis (Premium)

```bash
# Comprehensive security audit
ostruct run prompts/hybrid_analysis.j2 schemas/scan_result.json \
  -f code examples/basic/app.py \
  --file ci:code_exec examples/basic/app.py \
  --sys-file prompts/system.txt

# üéØ RECOMMENDED: Entire project analysis (all files)
ostruct run prompts/hybrid_analysis.j2 schemas/scan_result.json \
  --dir code examples \
  --dir ci:code_exec examples \
  --sys-file prompts/system.txt \
  --timeout 300

# For multiple files, run separate analyses:
ostruct run prompts/hybrid_analysis.j2 schemas/scan_result.json \
  -f code examples/intermediate/api_service.py \
  --file ci:code_exec examples/intermediate/api_service.py \
  --sys-file prompts/system.txt \
  --timeout 180

# Advanced microservice analysis
ostruct run prompts/hybrid_analysis.j2 schemas/scan_result.json \
  -f code examples/advanced/services/auth/auth_service.py \
  --file ci:code_exec examples/advanced/services/auth/auth_service.py \
  --sys-file prompts/system.txt \
  --timeout 240
```

## ‚ö†Ô∏è **Important Considerations**

### **Timeout Guidelines**

Different approaches have different processing times:

* **Static Analysis**: Usually completes in 30-60 seconds
* **Code Interpreter**: May take 60-180 seconds (includes environment setup)
* **Hybrid Analysis**: Can take 120-300 seconds (most comprehensive)

**Recommended timeout values:**

```bash
# For simple files (< 1000 lines)
--timeout 120

# For complex files (1000-5000 lines)
--timeout 180

# For large files or microservices (> 5000 lines)
--timeout 240
```

### **Multiple File Analysis**

**üéØ RECOMMENDED: Directory-Based Analysis**

For comprehensive project analysis, use directory options to analyze all files at once:

```bash
# Static Analysis - Entire project
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  --dir code examples --sys-file prompts/system.txt

# Code Interpreter - Entire project
ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  --dir ci:code examples --sys-file prompts/system.txt

# Hybrid Analysis - Entire project
ostruct run prompts/hybrid_analysis.j2 schemas/scan_result.json \
  --dir code examples --dir ci:code_exec examples --sys-file prompts/system.txt
```

**Alternative: Individual File Analysis**

**Current Limitation**: Templates expect a single `code` variable, so multiple files must be analyzed separately:

```bash
# ‚ùå This won't work (duplicate variable names):
ostruct run prompts/static_analysis.j2 schemas/scan_result.json \
  -f code file1.py -f code file2.py

# ‚úÖ Instead, run separate analyses:
ostruct run prompts/static_analysis.j2 schemas/scan_result.json -f code file1.py
ostruct run prompts/static_analysis.j2 schemas/scan_result.json -f code file2.py
```

### **Template Variable Requirements**

All current templates expect these specific variables:

* **Static Analysis**: `code` (file array)
* **Code Interpreter**: `code` (file array)
* **Hybrid Analysis**: `code` (template access) + `code_exec` (execution environment)

## üìà **Expected Results**

All approaches will find the same core security vulnerabilities but with different levels of detail:

### Static Analysis Results

* ‚úÖ **Comprehensive** vulnerability detection
* ‚úÖ **Practical** remediation guidance
* ‚úÖ **Fast** processing with direct file access
* ‚úÖ **Cost-effective** baseline security assessment
* ‚úÖ **Good** severity assessment (High/Medium/Low)

### Code Interpreter Results

* ‚úÖ **Evidence-based** analysis with specific code references
* ‚úÖ **AST parsing** and structural analysis
* ‚úÖ **Advanced pattern detection** using Python tools
* ‚úÖ **Professional audit-grade** output
* ‚úÖ **Superior** severity assessment (Critical/High/Medium/Low)

### Hybrid Analysis Results

* ‚úÖ **Cross-validation** between static and dynamic analysis
* ‚úÖ **Comprehensive** security and quality metrics
* ‚úÖ **Advanced execution** capabilities
* ‚úÖ **Real-time syntax** validation
* ‚úÖ **Maximum coverage** with multi-phase analysis

## üéØ **Recommendations**

### **For Most Projects: Code Interpreter** ‚≠ê

* **Same cost** as static analysis for single files ($0.18)
* **Significantly better** analysis quality with evidence-based findings
* **Professional audit-grade** output with AST parsing
* **Superior severity assessment** prevents false positives

### **For Budget-Conscious Projects: Static Analysis**

* **Lowest cost** for directory analysis ($0.26 vs $0.27)
* **Still finds all major** security vulnerabilities
* **Fast processing** with minimal resource usage
* **Good remediation advice** with specific line numbers

### **For Critical Applications: Hybrid Analysis**

* **Maximum analysis depth** for critical systems
* **Cross-validation capabilities** between static and dynamic
* **Advanced execution** and complexity analysis
* **Only 13% more expensive** for comprehensive coverage ($0.20 vs $0.18)

## üìÅ **Directory Structure**

```
.
‚îú‚îÄ‚îÄ README.md                    # This file
‚îú‚îÄ‚îÄ prompts/                     # AI prompts (three approaches)
‚îÇ   ‚îú‚îÄ‚îÄ static_analysis.j2       # Budget-friendly static analysis
‚îÇ   ‚îú‚îÄ‚îÄ code_interpreter.j2      # Professional security analysis (recommended)
‚îÇ   ‚îú‚îÄ‚îÄ hybrid_analysis.j2       # Comprehensive audit approach
‚îÇ   ‚îî‚îÄ‚îÄ system.txt              # AI security expertise definition
‚îú‚îÄ‚îÄ schemas/                     # Output structure
‚îÇ   ‚îî‚îÄ‚îÄ scan_result.json        # Vulnerability report schema
‚îú‚îÄ‚îÄ examples/                    # Sample vulnerable code
‚îÇ   ‚îú‚îÄ‚îÄ basic/                  # Simple web application
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.py              # Flask app with SQL injection, XSS
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt    # Dependencies
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SOLUTION.md         # Security fixes guide
‚îÇ   ‚îú‚îÄ‚îÄ intermediate/           # API service
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api_service.py      # REST API with auth vulnerabilities
‚îÇ   ‚îî‚îÄ‚îÄ advanced/              # Microservices architecture
‚îÇ       ‚îî‚îÄ‚îÄ services/          # Service implementations
‚îÇ           ‚îî‚îÄ‚îÄ auth/          # Authentication service
‚îÇ               ‚îú‚îÄ‚îÄ auth_service.py    # JWT, Redis vulnerabilities
‚îÇ               ‚îú‚îÄ‚îÄ jwt_config.json    # Insecure JWT config
‚îÇ               ‚îú‚îÄ‚îÄ redis.conf         # Redis configuration
‚îÇ               ‚îú‚îÄ‚îÄ requirements.txt   # Service dependencies
‚îÇ               ‚îî‚îÄ‚îÄ SOLUTION.md        # Microservice security guide
‚îî‚îÄ‚îÄ docs/                       # Documentation
    ‚îú‚îÄ‚îÄ customization.md        # How to customize scans
    ‚îî‚îÄ‚îÄ rules.md               # Security rules reference
```

## üîç **Vulnerability Detection Capabilities**

All approaches detect:

### **Injection Vulnerabilities**

* SQL injection (string concatenation, format strings)
* OS command injection via subprocess, os.system
* Code injection through eval(), exec(), compile()
* LDAP injection, XML injection

### **Cross-Site Scripting (XSS)**

* Unescaped output in web contexts
* Direct rendering of user input
* Unsafe template rendering

### **Authentication & Authorization**

* Missing authentication checks
* Weak password policies
* Session management issues
* Privilege escalation vulnerabilities

### **Cryptographic Issues**

* Hardcoded passwords, API keys, secrets
* Weak cryptographic algorithms
* Plain text password storage
* Missing password hashing

### **Input Validation Issues**

* Missing input sanitization
* Insufficient data validation
* Path traversal vulnerabilities
* Buffer overflow potential

## üîß **Integration Examples**

### GitHub Actions

```yaml
name: Security Scan
on: [push, pull_request]

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Security Analysis
        run: |
          # Professional security analysis (recommended)
          ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
            --file ci:code src/app.py \
            --sys-file prompts/system.txt \
            --output-file security_report.json
```

### GitLab CI

```yaml
security_scan:
  stage: test
  script:
    # Budget-friendly option for CI/CD
    - ostruct run prompts/static_analysis.j2 schemas/scan_result.json
        -f code src/app.py
        --sys-file prompts/system.txt
  artifacts:
    reports:
      junit: security_report.json
```

### Docker

```bash
# Containerized security scanning
docker run --rm -v $(pwd):/workspace ostruct/security-scanner \
  ostruct run prompts/code_interpreter.j2 schemas/scan_result.json \
  --file ci:code /workspace/src/app.py \
  --sys-file prompts/system.txt
```

## üìä **Performance Benchmarks**

Based on live testing with actual ostruct dry-runs:

### **Single File Analysis** (`examples/basic/app.py` - 1,656 bytes)

| Metric | Static | Code Interpreter | Hybrid |
|--------|--------|------------------|--------|
| **Input Tokens** | 6,762 | 6,406 | 15,970 |
| **Estimated Cost** | $0.1807 | $0.1799 | $0.2038 |
| **Context Utilization** | 18.1% | 17.8% | 25.3% |
| **Analysis Quality** | Good | Superior | Comprehensive |
| **Processing Time** | Fastest | Fast | Moderate |

### **Directory Analysis** (All example files - 4 Python files, ~5KB total)

| Metric | Static | Code Interpreter | Hybrid |
|--------|--------|------------------|--------|
| **Input Tokens** | 39,354 | ~40,000* | ~55,000* |
| **Estimated Cost** | $0.2622 | ~$0.27* | ~$0.35* |
| **Context Utilization** | 43.5% | ~45%* | ~60%* |
| **Analysis Quality** | Comprehensive | Superior | Maximum |
| **Processing Time** | Fast | Moderate | Slower |

*Estimated based on static analysis baseline + tool overhead

## üéì **Educational Value**

This example demonstrates:

1. **Cost vs Quality Trade-offs**: Clear metrics for decision making
2. **File Routing Approaches**: When to use `--file` vs `--file ci:` vs both
3. **AI-Powered Security Analysis**: Beyond traditional static analysis tools
4. **Template Optimization**: Expert-optimized prompts for better results
5. **Production-Ready Templates**: Real-world security analysis capabilities

## üîó **Key Benefits Over Traditional Scanners**

1. **Contextual Understanding**
   * Understands code semantics and flow
   * Reduces false positives through context
   * Identifies complex vulnerability patterns

2. **Intelligent Analysis**
   * Prioritizes vulnerabilities by risk
   * Provides detailed exploit scenarios
   * Suggests specific remediation steps

3. **Flexible Approaches**
   * Choose based on budget and requirements
   * Scale from basic to comprehensive analysis
   * Validated performance metrics for planning

4. **Developer-Friendly Output**
   * Clear, actionable explanations
   * Code-specific fix suggestions
   * Professional audit-grade reports

## üöÄ **Getting Started**

1. **Choose your approach** based on budget and requirements
2. **Run the analysis** using the appropriate template
3. **Review the results** in the JSON output
4. **Implement fixes** based on remediation guidance
5. **Integrate** into your CI/CD pipeline

Start with the **Code Interpreter approach** for the best balance of cost and quality!
