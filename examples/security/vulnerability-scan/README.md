# Security Vulnerability Scanning

This use case demonstrates how to perform automated security vulnerability scanning across codebases using the OpenAI Structured CLI. It combines static analysis with AI-powered reasoning to identify potential security issues, suggest fixes, and provide detailed explanations.

## Features

- Code pattern-based vulnerability detection
- Dependency vulnerability scanning
- Security best practice validation
- Intelligent vulnerability prioritization
- Detailed remediation suggestions
- Support for multiple programming languages

## Directory Structure

```
.
├── README.md           # This file
├── prompts/           # AI prompts
│   ├── system.txt     # AI's security expertise definition
│   └── task.j2        # Scan request template
├── schemas/           # Output structure
│   └── scan_result.json
├── examples/          # Sample code to scan
│   ├── basic/        # Simple web application
│   │   ├── app.py        # Flask application
│   │   └── requirements.txt
│   ├── intermediate/ # API service
│   │   ├── src/         # Source code
│   │   └── deps/        # Dependencies
│   └── advanced/     # Microservices
│       ├── services/    # Service implementations
│       └── shared/      # Shared libraries
└── docs/             # Documentation
    ├── customization.md # How to customize scans
    └── rules.md        # Security rules reference
```

## Usage

1. **Basic Usage**:

   Generic pattern:

   ```bash
   ostruct run prompts/task.j2 schemas/scan_result.json \
     -d code path/to/code \
     -R \
     --sys-file prompts/system.txt
   ```

   Ready to run example:

   ```bash
   ostruct run prompts/task.j2 schemas/scan_result.json \
     -d code examples/basic \
     -R \
     --sys-file prompts/system.txt
   ```

2. **With Specific Rules**:

   Generic pattern:

   ```bash
   ostruct run prompts/task.j2 schemas/scan_result.json \
     -d code path/to/code \
     -R \
     --sys-file prompts/system.txt \
     -J rules='["web","api"]'
   ```

   Ready to run example:

   ```bash
   ostruct run prompts/task.j2 schemas/scan_result.json \
     -d code examples/intermediate/src \
     -R \
     --sys-file prompts/system.txt \
     -J rules='["web","api"]'
   ```

3. **Dependency Scan**:

   Generic pattern:

   ```bash
   ostruct run prompts/task.j2 schemas/scan_result.json \
     -d code path/to/code \
     -R \
     --sys-file prompts/system.txt \
     -V check_dependencies=true
   ```

   Ready to run example:

   ```bash
   ostruct run prompts/task.j2 schemas/scan_result.json \
     -d code examples/advanced \
     -R \
     --sys-file prompts/system.txt \
     -V check_dependencies=true
   ```

## Example Files

1. **Basic Application**
   - Simple web application with common vulnerabilities
   - Dependency management files
   - Configuration files

2. **Intermediate Setup**
   - REST API implementation
   - Authentication flows
   - Database interactions

3. **Advanced Example**
   - Microservices architecture
   - Inter-service communication
   - Shared security components

## Integration

### GitHub Actions

```yaml
- name: Security Scan
  run: |
    ostruct run prompts/task.j2 schemas/scan_result.json \
      -d code ./src \
      -R \
      --sys-file prompts/system.txt
```

### GitLab CI

```yaml
security_scan:
  script:
    - ostruct run prompts/task.j2 schemas/scan_result.json \
        -d code ./src \
        -R \
        --sys-file prompts/system.txt
```

## Key Benefits Over Traditional Scanners

1. **Contextual Understanding**
   - Understands code semantics and flow
   - Reduces false positives through context
   - Identifies complex vulnerability patterns

2. **Intelligent Analysis**
   - Prioritizes vulnerabilities by risk
   - Provides detailed exploit scenarios
   - Suggests specific remediation steps

3. **Comprehensive Coverage**
   - Scans application code
   - Checks dependencies
   - Validates configurations
   - Reviews security practices

4. **Developer-Friendly Output**
   - Clear, actionable explanations
   - Code-specific fix suggestions
   - Best practice recommendations

## Prerequisites

- OpenAI Structured CLI installed
- OpenAI API key configured
- Source code to scan

## Limitations

- Dynamic runtime vulnerabilities require additional tools
- Some language-specific features may need custom rules
- Large codebases are processed in chunks
