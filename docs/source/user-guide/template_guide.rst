Template Guide
==============

Learn how to create powerful Jinja2 templates for ostruct that combine static text with dynamic content, file processing, and advanced filtering capabilities. **Templates are prompt templates** - they define the text that gets sent to OpenAI models to generate structured JSON responses.

.. note::
   This guide assumes no prior knowledge of Jinja2. Templates use a customized Jinja2 environment with ostruct-specific enhancements.

.. tip::
   **Schema Creation Tool**: When creating templates, use the **Schema Generator** meta-tool to automatically create corresponding JSON schemas:

   .. code-block:: bash

      tools/schema-generator/run.sh -o my_schema.json my_template.j2

   This ensures your schemas are OpenAI-compliant and match your template structure.

Understanding Templates
=======================

What Are ostruct Templates?
---------------------------

ostruct templates are **prompt templates** - Jinja2 files that define the text sent to OpenAI models. The model receives your rendered template as its prompt and generates structured JSON responses based on your schema.

**Template Flow:**
1. Your template is rendered with data (files, variables, etc.)
2. The rendered text becomes the prompt sent to the OpenAI model
3. The model generates a JSON response matching your schema
4. ostruct returns the structured output

Template Structure
------------------

ostruct templates are Jinja2 files (typically with ``.j2`` extension) that can include:

- **Static text** - Regular content that appears as-is in the prompt
- **Variables** - Dynamic content from files, CLI arguments, or system data
- **Control structures** - Loops, conditionals, and logic for complex prompts
- **Filters** - Functions to process and transform data
- **YAML frontmatter** - Configuration and system prompts

Basic Template Example
----------------------

.. code-block:: jinja

   ---
   system_prompt: You are an expert data analyst.
   ---
   Analyze this configuration file:

   {{ config_yaml.content }}

   Summary of findings:
   {% for file in logs %}
   - {{ file.name }}: {{ file.content | word_count }} words
   {% endfor %}

Variables and Data Access
=========================

Variable Sources
----------------

ostruct makes data available through several sources:

1. **File Variables** - From file routing options (``--file``, ``--file ci:``, ``--file fs:``)
2. **Directory Variables** - From directory routing options (``--dir``, ``--dir ci:``, ``--dir fs:``)
3. **Literal Variables** - From ``-V key=value`` command line arguments
4. **JSON Variables** - From ``-J key=json`` command line arguments for complex data structures
5. **Environment Variables** - From ``-E`` or ``--env`` flags
6. **Computed Variables** - Generated by ostruct (timestamps, metadata, etc.)

File Variables
==============

Understanding File Routing
---------------------------

Files are routed to different tools using the ``--file`` flag with target specifications:

.. list-table:: File Routing Options
   :header-rows: 1
   :widths: 20 30 50

   * - Flag
     - Purpose
     - Template Access
   * - ``--file`` (Template)
     - File available in template only
     - Direct content access via ``.content``
   * - ``--file ci:`` (Code Interpreter)
     - Upload for code execution and analysis
     - Analysis results and execution context
   * - ``--file fs:`` (File Search)
     - Upload for semantic search and retrieval
     - Search results and document context

Variable Naming Rules
---------------------

ostruct automatically generates variable names from file paths following these rules:

.. list-table::
   :header-rows: 1
   :widths: 40 35 25

   * - File Path
     - Generated Variable
     - Pattern Applied
   * - ``config.yaml``
     - ``config_yaml``
     - Replace dots with underscores
   * - ``my-file.txt``
     - ``my_file_txt``
     - Replace hyphens with underscores
   * - ``hello.world.json``
     - ``hello_world_json``
     - Replace all non-alphanumeric with underscores
   * - ``123data.csv``
     - ``_123data_csv``
     - Prepend underscore if starts with digit

Auto-Naming Examples
--------------------

.. code-block:: bash

   # Auto-naming syntax
   ostruct run template.j2 schema.json --file config config.yaml
   # Creates variable: config_yaml

   ostruct run template.j2 schema.json --file ci:data sales-data.csv
   # Creates variable: sales_data_csv

.. code-block:: jinja

   # Access in template (IMPORTANT: use .content)
   Configuration settings:
   {{ config_yaml.content }}

   Sales data summary:
   {{ sales_data_csv.content | word_count }} characters

Custom Variable Names
---------------------

Override auto-naming with explicit variable names:

.. code-block:: bash

   # Two-argument alias syntax
   ostruct run template.j2 schema.json --file app_config config.yaml

.. code-block:: jinja

   # Access with custom name (IMPORTANT: use .content)
   Application configuration:
   {{ app_config.content }}

**Important: File Content Access**

All file variables in ostruct require the ``.content`` property to access file content:

.. code-block:: jinja

   ✅ Correct:   {{ my_file.content }}
   ❌ Incorrect: {{ my_file }}  # Shows guidance message, not content

If you accidentally use ``{{ my_file }}`` without ``.content``, you'll see a helpful message like:
``[File 'config.yaml' - Use {{ my_file.content }} to access file content]``

File Variable Properties
------------------------

Each file variable provides these properties:

**Content and Path Information:**

.. code-block:: jinja

   {{ file.content }}        <!-- File contents as string -->
   {{ file.path }}           <!-- Relative path from base directory -->
   {{ file.abs_path }}       <!-- Absolute filesystem path -->
   {{ file.name }}           <!-- File name with extension -->

**File Properties:**

.. code-block:: jinja

   {{ file.name }}           <!-- Filename with extension -->
   {{ file.extension }}      <!-- Extension (e.g., "txt") -->
   {{ file.path.stem }}      <!-- Name without extension (pathlib) -->
   {{ file.path.parent }}    <!-- Parent directory path (pathlib) -->

**Metadata:**

.. code-block:: jinja

   {{ file.size }}           <!-- File size in bytes -->
   {{ file.mtime }}          <!-- Modification time -->
   {{ file.encoding }}       <!-- File encoding -->
   {{ file.hash }}           <!-- File hash -->

**Type Checking:**

.. code-block:: jinja

   {% if file.exists %}      <!-- File exists -->

File References (Optional)
===========================

File references provide an **optional** mechanism to reference attached files in templates using ``{{ file_ref("alias") }}`` syntax. When used, files are automatically included in an XML appendix at the end of your prompt.

**This is completely optional** - you can always access files directly in templates using standard Jinja2 syntax if you prefer manual control over formatting and placement.

Quick Start with File References
---------------------------------

1. Attach files via CLI:

   .. code-block:: bash

      ostruct run template.j2 schema.json \
        --dir source-code src/ \
        --file config config.yaml \
        --collect data-files @filelist.txt

2. Reference in template:

   .. code-block:: jinja

      Analyze the source code in {{ file_ref("source-code") }}.
      Check the configuration in {{ file_ref("config") }}.
      Review the data files in {{ file_ref("data-files") }}.

3. Output includes references and XML appendix:

   .. code-block:: text

      Analyze the source code in <source-code>.
      Check the configuration in <config>.
      Review the data files in <data-files>.

      <files>
        <dir alias="source-code" path="src/">
          <file path="main.py">
            <content><![CDATA[...]]></content>
          </file>
        </dir>
        <file alias="config" path="config.yaml">
          <content><![CDATA[...]]></content>
        </file>
        <collection alias="data-files" path="@filelist.txt">
          <file path="data1.csv">
            <content><![CDATA[...]]></content>
          </file>
        </collection>
      </files>

Automatic vs Manual File Formatting
------------------------------------

**Automatic File References (Optional):**

.. code-block:: jinja

   {# In your template - automatic XML appendix #}
   Review the configuration in {{ file_ref("config") }}.
   Analyze the source code in {{ file_ref("source") }}.
   Process the data files in {{ file_ref("data") }}.

**Manual File Formatting (Alternative):**

You can access files directly and format them however you prefer:

.. code-block:: jinja

   {# Manual markdown formatting #}
   ## Configuration Analysis

   ```yaml
   {{ config.content }}
   ```

   ## Source Code Files

   {% for file in source %}
   ### {{ file.name }}
   ```{{ file.name.split('.')[-1] }}
   {{ file.content }}
   ```
   {% endfor %}

**Mixed Approach:**

You can combine both approaches in the same template:

.. code-block:: jinja

   {# Manual formatting for main analysis #}
   ## Quick Overview
   The configuration contains {{ config.content | length }} characters.

   {# Automatic XML appendix for detailed reference #}
   For complete file contents, see {{ file_ref("config") }} and {{ file_ref("source") }}.

File Placement Strategy
-----------------------

LLM performance is heavily influenced by the position of information in the prompt. Research confirms that models recall information best when it is placed at the **very beginning (primacy)** or the **very end (recency)** of the context window. Information placed in the middle is more likely to be overlooked (a phenomenon known as the "Lost in the Middle" problem).

Use this principle to guide your choice between manual and automatic file inclusion:

- **For Critical Files:** Manually place your most important file(s) immediately after your primary instructions at the **beginning** of the prompt. This puts them in a high-attention zone.
- **For Reference Material:** Use the automatic ``file_ref()`` appendix for all supporting files. This correctly places them at the **end** of the prompt, another high-attention zone.

**Best Practice Example:**

.. code-block:: jinja

   {# Critical file is placed manually at the top #}
   Please review this Python script for performance issues.

   ```python
   {{ source['main.py'].content }}
   ```

   My main concern is the efficiency of the data processing loop.
   Analyze the script above and use the attached logs and configuration for context.

   Supporting files for your analysis: {{ file_ref("logs") }} {{ file_ref("config") }}

Directory Variables
===================

Working with Directory Collections
-----------------------------------

Directory variables contain multiple files and always behave as collections:

.. code-block:: jinja

   {# Always iterate over directory variables #}
   {% for file in source_code %}
   ## {{ file.name }}
   {{ file.content }}
   {% endfor %}

**Important:** The most important principle for file handling in ostruct templates is **uniform iteration**: always treat file variables as collections, even when they contain just one file. This makes your templates work reliably regardless of how users attach files.

**Uniform Template Example:**

.. code-block:: jinja

   {# Works with both single files and directories #}
   {% for file in code %}
   ### {{ file.name }}
   ```{{ file.extension or 'text' }}
   {{ file.content }}
   ```
   {% endfor %}

This template works with either:
- ``ostruct run template.j2 schema.json --file code main.py`` (single file)
- ``ostruct run template.j2 schema.json --dir code ./src/`` (multiple files)

Directory Routing Strategies
-----------------------------

ostruct provides two approaches for directory routing, each suited to different template use cases:

**Auto-Naming for Specific Structures:**

Use auto-naming when your template is designed for a specific directory structure:

.. code-block:: bash

   ostruct run template.j2 schema.json --dir config ./config_files     # → config_files variable
   ostruct run template.j2 schema.json --dir ci:data ./datasets        # → datasets variable

.. code-block:: jinja

   {# Template must know actual directory names #}
   Configuration files:
   {% for file in config_files %}
   - {{ file.name }}: {{ file.content | word_count }} words
   {% endfor %}

**Aliases for Reusable Templates:**

Use aliases when your template needs to work with different directory structures:

.. code-block:: bash

   ostruct run template.j2 schema.json --dir app_config ./settings      # → app_config variable
   ostruct run template.j2 schema.json --dir ci:source_code ./src       # → source_code variable

.. code-block:: jinja

   {# Template uses stable variable names #}
   Application configuration:
   {% for file in app_config %}
   - {{ file.name }}: {{ file.content | word_count }} words
   {% endfor %}

**Template Reusability**: Use aliases (``--dir alias``, ``--dir ci:alias``, ``--dir fs:alias``) for templates that need to work across different projects or directory structures.

Literal and JSON Variables
===========================

Simple Variables
----------------

Pass simple values using ``-V``:

.. code-block:: bash

   ostruct run template.j2 schema.json -V env=production -V debug=false

.. code-block:: jinja

   Environment: {{ env }}
   Debug mode: {{ debug }}

Complex JSON Variables
-----------------------

Pass structured data using ``-J``:

.. code-block:: bash

   ostruct run template.j2 schema.json -J config='{"database":{"host":"localhost","port":5432},"features":["auth","billing"]}'

.. code-block:: jinja

   Database host: {{ config.database.host }}
   Features: {{ config.features | join(", ") }}

Template Filters
================

ostruct provides many built-in filters for data processing:

**Text Processing:**
- ``{{ text | word_count }}`` - Count words
- ``{{ text | char_count }}`` - Count characters
- ``{{ text | length }}`` - Count characters (built-in)
- ``{{ text | strip }}`` - Remove whitespace

**Data Conversion:**
- ``{{ json_text | from_json }}`` - Parse JSON (custom filter)
- ``{{ data | to_json }}`` - Convert to JSON (custom filter)
- ``{{ data | tojson }}`` - Convert to JSON (built-in filter)

**File Operations:**
- ``{{ files | single }}`` - Extract single file from collection
- ``{{ file.name }}`` - Get filename (FileInfo property)
- ``{{ file.path }}`` - Get full file path (FileInfo property)

**Safety and Validation:**
- ``{{ value | default("fallback") }}`` - Provide default value
- ``{{ safe_get("config.database.host", "localhost") }}`` - Safe nested access

Control Structures
===================

Conditionals
------------

.. code-block:: jinja

   {% if config_yaml is defined %}
   Configuration found: {{ config_yaml.name }}
   {% else %}
   No configuration provided.
   {% endif %}

   {% if files | length > 0 %}
   Processing {{ files | length }} files...
   {% endif %}

Loops
-----

.. code-block:: jinja

   {% for file in source_code %}
   ## File: {{ file.name }}
   {{ file.content }}

   {% if not loop.last %}---{% endif %}
   {% endfor %}

Error Handling
--------------

.. code-block:: jinja

   {# Defensive template coding #}
   {% if source_files is defined and source_files | length > 0 %}
     {% for file in source_files %}
     - {{ file.name }}: {{ file.content | word_count }} words
     {% endfor %}
   {% else %}
   No source files provided.
   {% endif %}

YAML Frontmatter
================

System Prompts
--------------

Add configuration and system prompts to templates using YAML frontmatter:

.. code-block:: jinja

   ---
   system_prompt: |
     You are an expert code reviewer. Focus on:
     - Security vulnerabilities
     - Performance issues
     - Best practices
   ---

   Please review this code:
   {{ code.content }}

Shared System Prompts
---------------------

The ``include_system:`` feature allows you to share common system prompt content across multiple templates:

.. code-block:: jinja

   ---
   include_system: shared/expert.txt
   system_prompt: |
     Additionally, focus on deployment readiness.
   ---

   Review this application for production deployment:
   {{ app_code.content }}

**Benefits:**
- **Maintain consistency** across multiple templates with shared expertise
- **Reduce duplication** by centralizing common prompt patterns
- **Enable specialization** by adding template-specific guidance
- **Version control** shared prompts independently from templates

Template Debugging
==================

Debug Variables
---------------

Use ``--template-debug vars`` to see all available variables:

.. code-block:: bash

   ostruct run template.j2 schema.json --file config config.yaml --template-debug vars

Dry Run Testing
---------------

Always use ``--dry-run`` to validate templates during development:

.. code-block:: bash

   ostruct run template.j2 schema.json --file data report.xlsx --dry-run

Template Expansion Debugging
-----------------------------

Debug the template rendering process:

.. code-block:: bash

   # Debug template expansion
   ostruct run template.j2 schema.json --template-debug post-expand --file config config.yaml

Best Practices
==============

Template Design Principles
---------------------------

1. **Uniform Iteration**: Always treat file variables as collections
2. **Defensive Coding**: Check if variables exist before using them
3. **Clear Instructions**: Write clear, specific prompts for the model
4. **Strategic File Placement**: Use primacy/recency effects for important content
5. **Consistent Naming**: Use aliases for reusable templates

Real-World Examples
===================

Code Review Template
--------------------

This template works whether the user provides one file or an entire directory:

.. code-block:: jinja

   ---
   system_prompt: You are an expert code reviewer.
   ---

   Please review the following code for security issues, performance problems, and best practices:

   {% for file in code %}
   ## {{ file.name }}
   ```{{ file.extension or 'text' }}
   {{ file.content }}
   ```

   {% endfor %}

   Focus on:
   1. Security vulnerabilities
   2. Performance bottlenecks
   3. Code quality issues
   4. Best practice violations

Multi-File Analysis Template
----------------------------

.. code-block:: jinja

   ---
   system_prompt: You are a senior software architect.
   ---

   Analyze this codebase structure and provide architectural recommendations:

   ## Project Overview
   Total files: {{ source_code | length }}

   ## File Analysis
   {% for file in source_code %}
   ### {{ file.path }}
   - Size: {{ file.content | char_count }} characters
   - Type: {{ file.extension or 'unknown' }}
   {% if file.content | char_count < 1000 %}

   ```{{ file.extension or 'text' }}
   {{ file.content }}
   ```
   {% endif %}
   {% endfor %}

   Please provide:
   1. Architecture assessment
   2. Code organization recommendations
   3. Potential improvements

See Also
========

- :doc:`template_quick_reference` - Quick syntax reference
- :doc:`advanced_patterns` - Advanced template techniques
- :doc:`cli_reference` - Command-line options
- :doc:`tool_integration` - Multi-tool integration patterns
